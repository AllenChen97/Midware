# Mysql

## 一、概览
### 1. 课程版本：mysql 5.7.32
- Percona Server 基于Mysql性能改进，从mysql迁移过来方便,优先于mysql提供运维面板功能。是《高性能mysql的作者》
- Postgre SQL 稳定性极强，并发性能很高，达到一定压力阈值之后再继续施压 表现也趋于稳定，数据类型高度丰富。- 加州伯克利
- SQLite 物联网首选，遍布最广泛，连进程都没有一般不对互联网进行服务

### 2. 体系架构
- 连接池：一般连接数 = CPU核数 * 2 性能最好
- 管理工具和服务
- server层
  - SQL接口
  - 编译器
  - 执行器
  - 缓存：在mysql5.7里面都是默认关闭的，只能在配置里面修改不能通过命令，并且命中要求严苛（命中两次且大小写敏感），加上并发锁会对整体性能有负作用，引擎里面也有缓存(innoDB)
- 插件式存储引擎：innoDB
- 文件和日志系统

### 3. linux操作
#### 3.1. bin
- 启动/关闭
```shell
# 脚本：mysqld，mysqld_safe 自动重启 有错误日志功能
# 更常用mysql.server，底层调用的还是 mysqld_safe
ln -s xxx xxx # 创建链接
mysql.server start
```
- mysqld_multi
- mysqladmin
- mysqldump 以sql语句来进行逻辑备份

#### 3.2. 参数
- 在my.cnf指定参数
```shell
mysqld_safe --default-file = xxx.cnf
```
- 参数分为：动态、静态和全局、会话。
```sql
set @@global.datadir='/xxx'
```
- 重要参数：  
  - log_error 错误日志
  - slow query log 慢查询，默认不开启
  - general_log 查询日志，默认不开启
  - bin log 二进制文件 对数据库的所有更改,用于从库同步等

- 开启查询日志，并查询
```sql
set global general_log=on;
set global log_output='TABLE,FILE'; -- 表和文件都写

select * from general_log
```

### 4. 字段类型
- decimal优化：用 bigint/long 来表示整数和小数部分
- bigint优化：如果一个 long 不够那就两个long64位加起来
- varchar可以变化长度，但3-4个字符的那种最好还是用char，因为varchar会用2-3个字符去记录长度
- char除了短的，还是和用来存所有值的长度相近的，即长度不分散的 或者 定长的，如身份证 加盐后的密码

- datetime 1001-9999, timestamp 1970-2038 跟时区有关，都是到秒

## 二、引擎
### 1. 所有引擎介绍
```sql
show engines; -- 查mysql支持的所有引擎
show variables like '%storage_engine%'; -- 查mysql当前引擎
```
少用的：
- Archive 压缩数据，占用空间小，适合频繁写入，少读取的场景
- Blackhold 数据马上丢弃。适合在复制功能中，用作主数据和从库之间的引擎，减轻推送数据时对主库的压力
- CSV 不支持索引，用于数据交换
- Ferderated 代理引擎
- Memory 全用内存操作 很快，但设备要求高、断电就没、并发性能不高
- NDB 集群引擎

值得介绍：
- Percona 的 XtraDB引擎
- TukuDB 使用分型树的数据结构(innoDB用B+树)，对写入操作做大量的优化，读性能接近InnoDB,适合短事务
- InfoBright 列存储，从行存储转换到列存储比较耗时，读取很快
- 还有其他图数据库


### 2. InnoDB
- 没有特殊场景都用InnoDB
- 虽然不同的表可以使用不同的引擎，但官方并不建议引擎混用，会带来很多问题 
```sql
-- 更改引擎:加锁并复制新的一份数据到新的引擎上面
alter table xxx engine = innobd; 
```

会把数据放在表空间，可以对应一个或多个数据文件  
系统表空间ibdata1,可以在配置文件中修改，允许数据放在不同的磁盘上  

独立表空间，每个表都有单独的空间  
数据和索引放在同一个空间，myisam则分开存放  

## 三、事务和范式

### 1. 事务

#### 1.1. ACID 中的隔离级别
![](.\img\脏读.png)
- 脏读：一个事务读取到了另外一个事务修改但**未提交**的数据
- 幻读：另一个事务将**新纪录添加到**正在读取的事务中

- 锁定读，当前读

#### 1.2. 保存点
- 在长事务中，某个语句失败不用全部回滚，就可以使用 ‘save point 保存点名’ 来控制。  

#### 1.3. 隐式提交
- DDL 会别隐式提交，即使没有写commit也会被提交掉。  
- 如果写了两个begin，或者lock table，从第一个begin到第二个begin之间的代码也会被隐式提交。  

### 2. 范式

### 2.1. 1NF - 3NF 复习
- 1NF：字段不可拆分，如：多个手机号拼接
- 2NF：字段不对主键依赖
- 3NF：字段甚至不对非主键依赖

### 2.2. 反范式
- 不遵循范式，允许少量的信息冗余，用空间换时间

## 四、索引
### 1. 索引结构
1. B+树 复习！ 重要
2. 磁盘与B+树
   - 硬盘寻找数据的顺序为：找到盘片、寻道、寻区、读取返回I/O，其中寻道时间占用最久
   - 所以数据放在同一个道上顺序读取要比在不同的轨道上读取要快很多，让数据尽可能顺序读写
   - 而磁盘中一个页的大小通常为16k，而数据库使用B+树可以让磁盘尽可能的顺序读取数据文件

### 2. 索引类型
1. 聚集/主键索引
   - 会自动生成一个B+树，就算没定义InnoDB也会自动生成一个row_id
   - 主键不能频繁修改，而且越离散越好
2. 辅助/二级索引
   - 主键索引会存放其他列的所有数据，但辅助索引只会存放**索引列**和**主键**，也是排好序的
   - 如果一个查询中用了多个二级索引，一般也只能用上一个，用哪个优化器来计算。其他的where条件只用作筛选辅助索引回表查出来的数据
3. 回表
   - 当通过辅助索引找到对应的主键时，回到主键索引的B+树中寻找数据
   - 回表次数越少，速度越快。
   - 优化器会比较回表次数和顺序查找哪个更快
   - myisam索引和数据文件分开放，所有的查询都要回表
![回表](img\回表.png) 
4. 联合索引
   - 多个列联合船舰的索引，只会建立一个索引
   - 逐个字段先后排序
5. 索引覆盖
   - 查询的列在联合索引的B+树之中，并不需要回表

### 3. 其他索引
6. 自适应哈希索引 AHI
   - 默认开启，对热点数据创建hash索引
   - innodb_adaptive_hash_index 和 innodb_adaptive_hash_index_parts 个数
7. 全文检索
   - 对于长文本的搜索，使用**倒排索引**进行优化
   - 倒排索引：将长文本分词，显示每个分词存在哪行里面
     ![倒排索引](img\倒排索引.png)
   - 全文检索非常复杂，ELK 就靠全文检索上市。所以在mysql中其实性能一般
### 4. 扫描空间
- where条件中，索引列使用筛选就会产生扫描空间。
- 扫描空间的判断

### 5. 三星索引




## 五、性能调优

